#version 410

#define RED vec4(1, 0, 0, 1)
#define GREEN vec4(0, 1, 0, 1)
#define BLUE vec4(0, 0, 1, 1)
#define BLACK vec4(0, 0, 0, 1)

/**
 * Bare bones "clean room" shader with a geo passthrough
 */

uniform mat4 u_MVPMatrix : WorldViewProjection;
uniform mat4 u_ModelMatrix : World;
uniform mat4 u_NormalMatrix : WorldInverseTranspose;

// Camera world space position would be u_CameraMatrix[3].xyz
uniform mat4 u_CameraMatrix : ViewInverse;

// ---------------------------------------------
// Settings Group
// ---------------------------------------------
uniform vec3 u_SolidColor : DIFFUSE
<
    string UIName = "Solid Color";
    // string UIGroup = "Fill";
    string UIWidget = "Color";
> = {1, 0, 0};

uniform float u_TessOuter
<
    string UIName = "Tessellation Outer";
    // string UIGroup = "Misc";
> = 1.0;

uniform float u_TessInner
<
    string UIName = "Tessellation Inner";
    // string UIGroup = "Misc";
> = 1.0;

// ---------------------------------------------
// Shader inputs/outputs
// ---------------------------------------------
attribute appdata
{
	vec3 vertex : POSITION;
	vec3 normal : NORMAL;
};

// Vertex to Tessellation Control 
attribute v2t
{
	vec3 vertex : POSITION;
	vec3 normal : NORMAL;
    vec4 col : COLOR0;
};

// Tessellation Control to Tessellation Evaluation
attribute t2e
{
    vec3 vertex : POSITION0;
	vec3 normal : NORMAL;
    vec4 col : COLOR0;
};

// Tessellation Evaluation to Geometry
attribute e2g
{
    vec3 vertex : POSITION0;
	vec3 normal : NORMAL;
    vec4 col : COLOR0;
};

// Geometry to Fragment
attribute g2f
{
    // vec4 clipPosition : SV_Position|POSITION0;
    vec3 worldNormal : NORMAL;
    vec3 worldPosition : TEXCOORD3;
	vec4 col : COLOR0;
};

attribute frag_out
{
	vec4 col : COLOR0;
};

GLSLShader vert
{
	void main()
	{
		o.normal = normal;
        o.vertex = vertex;
        o.col = BLACK;

        // gl_Position = u_MVPMatrix * vec4(vertex, 1);
	}
}

patchsize 3;
GLSLShader tcs
{
    void main()
    {
        // Index of current invocation 
        // (executed once per output CP in the patch)
        const uint index = gl_InvocationID;

        // Just select the matching input vertex and copy it over
        o[gl_InvocationID].vertex = input[index].vertex;
        o[gl_InvocationID].normal = input[index].normal;
        o[gl_InvocationID].col = input[index].col;

        // Calculate tessellation levels for only one of the invocations
        if (index == 1) {
            //gl_TessLevelOuter[0] corresponds to gl_InvocationID 1 and 2
            //gl_TessLevelOuter[1] corresponds to gl_InvocationID 0 and 1
            //gl_TessLevelOuter[2] corresponds to gl_InvocationID 2 and 0
            
            // # of segments on each edge of the triangle
            gl_TessLevelOuter[0] = u_TessOuter;
            gl_TessLevelOuter[1] = u_TessOuter;
            gl_TessLevelOuter[2] = u_TessOuter;

            // # of rings within the triangle, roughly
            gl_TessLevelInner[0] = u_TessInner;
        }
    }
}

// Or: fractional_even_spacing, fractional_odd_spacing
tesparams(triangles, equal_spacing, cw);
GLSLShader tes
{
    // Executed for every vertex in the patch generated by TCS + fixed func
    // Outputs a single vertex
    void main()
    {
        // Barycentric coordinates of the vertex are in gl_TessCoord
        // (weighted combination of all three vertices)
        float U = gl_TessCoord.x;
        float V = gl_TessCoord.y;
        float W = gl_TessCoord.z;
        
        // Get a new vertex position by multiplying each vertex in the 
        // triangle by the barycentric coordinates
        vec3 position = input[0].vertex * U + 
                        input[1].vertex * V +
                        input[2].vertex * W;

        // .. will need to suck less later.
        o.vertex = input[0].vertex;
        o.normal = input[0].normal;
        o.col = vec4(gl_TessCoord.xyz, 1);

        gl_Position = u_MVPMatrix * vec4(position, 1);
    }
}

GLSLShader geom
{
    // Input type: 6 vertices as GL_TRIANGLES_ADJACENCY 
    // layout(triangles_adjacency) in;
    layout(triangles) in; // for PNAEN18

    layout(triangle_strip, max_vertices = 15) out;

    // Passthrough GL_TRIANGLES_ADJACENCY
    void passthroughTriAdj() {
        int i;

        for (i = 0; i < 5; i += 2) {
            o.col = input[i].col;
            o.worldNormal = (u_ModelMatrix * vec4(input[i].normal, 0)).xyz;
            o.worldPosition = (u_ModelMatrix * vec4(input[i].vertex, 1)).xyz;

            gl_Position = u_MVPMatrix * vec4(input[i].vertex, 1);
            EmitVertex();
        }

        EndPrimitive();
    }

    // Passthrough GLSL_PNAEN18 
    void passthroughPNAEN() {
        int i;

        for (i = 0; i < 3; i++) {
            o.col = input[i].col;
            o.worldNormal = (u_ModelMatrix * vec4(input[i].normal, 0)).xyz;
            o.worldPosition = (u_ModelMatrix * vec4(input[i].vertex, 1)).xyz;

            gl_Position = u_MVPMatrix * vec4(input[i].vertex, 1);
            EmitVertex();
        }

        EndPrimitive();
    }

    void main() {
        passthroughTriAdj();
    }
}

// Wireframing geometry shader from Maya's example code.
// Used in the Wireframe technique to check tessellation / etc
GLSLShader GS_Wireframe
{
    layout(triangles) in;
    layout(line_strip, max_vertices = 6) out;

    void main()
    {
        o.col = input[0].col;
        o.col = BLACK;
        gl_Position = gl_in[0].gl_Position;
        EmitVertex();

        o.col = input[1].col;
        o.col = GREEN;
        gl_Position = gl_in[1].gl_Position;
        EmitVertex();

        EndPrimitive();

        o.col = input[1].col;
        o.col = GREEN;
        gl_Position = gl_in[1].gl_Position;
        EmitVertex();

        o.col = input[2].col;
        o.col = BLUE;
        gl_Position = gl_in[2].gl_Position;
        EmitVertex();

        EndPrimitive();

        o.col = input[2].col;
        o.col = BLUE;
        gl_Position = gl_in[2].gl_Position;
        EmitVertex();

        o.col = input[0].col;
        o.col = RED;
        gl_Position = gl_in[0].gl_Position;
        EmitVertex();

        EndPrimitive();
    }
}

GLSLShader frag
{
	void main()
	{
        col = input.col;
	}
}

technique Main
<
    string Transparency = "Opaque";
	string index_buffer_type = "GLSL_PNAEN18";
>
{
	pass p0
	{
		VertexShader (in appdata, out v2t o) = vert;
        TessControlShader (in v2t input, out t2e o) = tcs;
        TessEvaluationShader (in t2e input, out e2g o) = tes;
		// GeometryShader (in e2g input, out g2f o) = GS_Wireframe;
		PixelShader (in e2g input, out frag_out) = frag;
	}
}

technique Wireframe
<
    string Transparency = "Opaque";
    string index_buffer_type = "GLSL_PNAEN18";
>
{
    pass p0
	{
		VertexShader (in appdata, out v2t o) = vert;
        TessControlShader (in v2t input, out t2e o) = tcs;
        TessEvaluationShader (in t2e input, out e2g o) = tes;
		GeometryShader (in e2g input, out g2f o) = GS_Wireframe;
		PixelShader (in g2f input, out frag_out) = frag;
	}
}
