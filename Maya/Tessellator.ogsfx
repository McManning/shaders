#version 410

#define RED vec4(1, 0, 0, 1)
#define GREEN vec4(0, 1, 0, 1)
#define BLUE vec4(0, 0, 1, 1)
#define BLACK vec4(0, 0, 0, 1)

/**
 * Tessellation Experiments.
 * 
 * PN-AEN is detailed in:
 * http://developer.download.nvidia.com/whitepapers/2010/PN-AEN-Triangles-Whitepaper.pdf
 */

uniform mat4 u_MVPMatrix : WorldViewProjection;
uniform mat4 u_ModelMatrix : World;
uniform mat4 u_NormalMatrix : WorldInverseTranspose;

// Camera world space position would be u_CameraMatrix[3].xyz
uniform mat4 u_CameraMatrix : ViewInverse;

// ---------------------------------------------
// Settings Group
// ---------------------------------------------
uniform vec3 u_SolidColor : DIFFUSE
<
    string UIName = "Solid Color";
    // string UIGroup = "Fill";
    string UIWidget = "Color";
> = {1, 0, 0};

uniform float u_TessOuter
<
    string UIName = "Tessellation Outer";
    // string UIGroup = "Misc";
> = 1.0;

uniform float u_TessInner
<
    string UIName = "Tessellation Inner";
    // string UIGroup = "Misc";
> = 1.0;

uniform float u_TessShapeFactor
<
    string UIName = "Phong Tess Shape Factor";
> = 1.0;

// ---------------------------------------------
// Shader inputs/outputs
// ---------------------------------------------
attribute appdata
{
	vec3 vertex : POSITION;
	vec3 normal : NORMAL;
};

// Vertex to Tessellation Control 
attribute v2t
{
	vec3 vertex : POSITION;
	vec3 normal : NORMAL;
    vec4 col : COLOR0;
};

// Tessellation Control to Tessellation Evaluation
attribute c2e
{
    vec4 worldPosition : POSITION;
	vec3 normal : NORMAL;
    vec4 col : COLOR0;
    vec3 adjNormal : TEXCOORD2;
};

// Tessellation Evaluation to Geometry
attribute e2g
{
    vec4 worldPosition : POSITION;
	vec3 normal : NORMAL;
    vec4 col : COLOR0;
    vec3 adjNormal : TEXCOORD2;
};

// Geometry to Fragment
attribute g2f
{
    // vec4 clipPosition : SV_Position|POSITION0;
    vec3 normal : NORMAL;
    vec4 worldPosition : TEXCOORD3;
	vec4 col : COLOR0;
};

attribute frag_out
{
	vec4 col : COLOR0;
};

GLSLShader vert
{
	void main()
	{
		o.normal = normal;
        o.vertex = vertex;
        o.col = BLACK;

        // gl_Position = u_MVPMatrix * vec4(vertex, 1);
	}
}

patchsize 3;
GLSLShader tcs
{
    void main()
    {
        // Index of current invocation 
        // (executed once per output CP in the patch)
        const uint index = gl_InvocationID;

        // Just select the matching input vertex and copy it over
        o[gl_InvocationID].worldPosition = vec4(input[index].vertex, 1);
        o[gl_InvocationID].normal = input[index].normal;

        vec3 c = vec3(gl_InvocationID * 0.5 + 0.5);
        o[gl_InvocationID].col = vec4(c, 1); // input[index].col;

        // Calculate tessellation levels for only one of the invocations
        if (index == 1) {
            //gl_TessLevelOuter[0] corresponds to gl_InvocationID 1 and 2
            //gl_TessLevelOuter[1] corresponds to gl_InvocationID 0 and 1
            //gl_TessLevelOuter[2] corresponds to gl_InvocationID 2 and 0
            
            // # of segments on each edge of the triangle
            gl_TessLevelOuter[0] = u_TessOuter;
            gl_TessLevelOuter[1] = u_TessOuter;
            gl_TessLevelOuter[2] = u_TessOuter;

            // # of rings within the triangle, roughly
            gl_TessLevelInner[0] = u_TessInner;
        }
    }
}

// Or: fractional_even_spacing, fractional_odd_spacing
tesparams(triangles, equal_spacing, cw);
GLSLShader tes
{
    vec3 projectOntoPlane(vec3 point, vec3 planePoint, vec3 planeNormal)
    {
        return point - dot(point - planePoint, planeNormal) * planeNormal;
    }

    // Executed for every vertex in the patch generated by TCS + fixed func
    // Outputs a single vertex
    void main()
    {
        // Barycentric coordinates of the vertex are in gl_TessCoord
        // (weighted combination of all three vertices)
        float U = gl_TessCoord.x;
        float V = gl_TessCoord.y;
        float W = gl_TessCoord.z;
        
        // Compute linear tessellation using the barycentric coordinates
        vec3 position = input[0].worldPosition.xyz * U + 
                        input[1].worldPosition.xyz * V +
                        input[2].worldPosition.xyz * W;

        // Projection of the vertex into a tangent plane for each dominant vertex
        // Each is the PI_i(p(u, v)) term for Equation 3.
        vec3 pU = projectOntoPlane(position, input[0].worldPosition.xyz, input[0].normal.xyz);
        vec3 pV = projectOntoPlane(position, input[1].worldPosition.xyz, input[1].normal.xyz);
        vec3 pW = projectOntoPlane(position, input[2].worldPosition.xyz, input[2].normal.xyz);

        // Compute barycentric interpolation of each projection
        vec3 phongTess = U * pU + V * pV + W * pW;

        // Set position as an interpolation between linear and phong tessellation
        o.worldPosition = vec4(lerp(position, phongTess, u_TessShapeFactor), 1);

        o.normal = input[0].normal * U + 
                   input[1].normal * V +
                   input[2].normal * W;

        // o.col = vec4(gl_TessCoord.xyz, 1);
        o.col = vec4(1, 1, 1, 1);

        if (V < 0.001 && W < 0.001) { // on vert 0
            o.col = RED;
        }

        if (U < 0.001 && V < 0.001) { // on vert 1
            o.col = GREEN;
        }

        if (U < 0.001 && W < 0.001) { // on vert 2
            o.col = BLUE;
        }
        
        gl_Position = u_MVPMatrix * o.worldPosition;
    }
}

GLSLShader geom
{
    // Input type: 6 vertices as GL_TRIANGLES_ADJACENCY 
    // layout(triangles_adjacency) in;
    layout(triangles) in; // for PNAEN18

    layout(triangle_strip, max_vertices = 15) out;

    // Passthrough GL_TRIANGLES_ADJACENCY
    void passthroughTriAdj() {
        int i;

        for (i = 0; i < 5; i += 2) {
            o.col = input[i].col;
            o.worldNormal = (u_ModelMatrix * vec4(input[i].normal, 0)).xyz;
            o.worldPosition = (u_ModelMatrix * vec4(input[i].vertex, 1)).xyz;

            gl_Position = u_MVPMatrix * vec4(input[i].vertex, 1);
            EmitVertex();
        }

        EndPrimitive();
    }

    // Passthrough GLSL_PNAEN18 
    void passthroughPNAEN() {
        int i;

        for (i = 0; i < 3; i++) {
            o.col = input[i].col;
            o.worldNormal = (u_ModelMatrix * vec4(input[i].normal, 0)).xyz;
            o.worldPosition = (u_ModelMatrix * vec4(input[i].vertex, 1)).xyz;

            gl_Position = u_MVPMatrix * vec4(input[i].vertex, 1);
            EmitVertex();
        }

        EndPrimitive();
    }

    void main() {
        passthroughTriAdj();
    }
}

// Wireframing geometry shader from Maya's example code.
// Used in the Wireframe technique to check tessellation / etc
GLSLShader GS_Wireframe
{
    layout(triangles) in;
    layout(line_strip, max_vertices = 6) out;

    void main()
    {
        o.col = input[0].col;
        gl_Position = gl_in[0].gl_Position;
        EmitVertex();

        o.col = input[1].col;
        gl_Position = gl_in[1].gl_Position;
        EmitVertex();

        EndPrimitive();

        o.col = input[1].col;
        gl_Position = gl_in[1].gl_Position;
        EmitVertex();

        o.col = input[2].col;
        gl_Position = gl_in[2].gl_Position;
        EmitVertex();

        EndPrimitive();

        o.col = input[2].col;
        gl_Position = gl_in[2].gl_Position;
        EmitVertex();

        o.col = input[0].col;
        gl_Position = gl_in[0].gl_Position;
        EmitVertex();

        EndPrimitive();
    }
}

GLSLShader frag
{
	void main()
	{
        // col = vec4(input.normal, 1);
        col = input.col;
	}
}

technique Main
<
    string Transparency = "Opaque";
	string index_buffer_type = "GLSL_PNAEN18";
>
{
	pass p0
	{
		VertexShader (in appdata, out v2t o) = vert;
        TessControlShader (in v2t input, out c2e o) = tcs;
        TessEvaluationShader (in c2e input, out e2g o) = tes;
		// GeometryShader (in e2g input, out g2f o) = GS_Wireframe;
		PixelShader (in e2g input, out frag_out) = frag;
	}
}

technique Wireframe
<
    string Transparency = "Opaque";
    string index_buffer_type = "GLSL_PNAEN18";
>
{
    pass p0
	{
		VertexShader (in appdata, out v2t o) = vert;
        TessControlShader (in v2t input, out c2e o) = tcs;
        TessEvaluationShader (in c2e input, out e2g o) = tes;
		GeometryShader (in e2g input, out g2f o) = GS_Wireframe;
		PixelShader (in g2f input, out frag_out) = frag;
	}
}
