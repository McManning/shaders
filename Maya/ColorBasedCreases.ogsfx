#version 410

#include "Utility.ogsfh"
#include "Settings.ogsfh"

attribute appdata {
    vec3 position : POSITION;
	vec3 normal : NORMAL;
    vec4 color : COLOR0;
};
 
attribute vs_to_gs {
    vec4 worldPosition : POSITION;
	vec3 normal : NORMAL;
    vec4 color : TEXCOORD0;
    vec4 data1 : TEXCOORD1;
    int id : TEXCOORD2;
};

attribute gs_to_ps {
    vec4 worldPosition : POSITION;
	vec3 worldNormal : NORMAL;
    vec4 color : TEXCOORD0;

    // encoded data, meaning changes based on the generator of the vertex.
    // color.a defines the encoding (normal face, silhouette, crease)
    // normal face: xyz is the distance to the opposite edge (for wireframe drawing)
    // silhouette: TBD
    // crease: xy is the crease edge start position, zw is end position
    // vec4 encoded : TEXCOORD1;
    vec4 dist: TEXCOORD1;
};

attribute ps_out {
    vec4 color : TEXCOORD0;
};

GLSLShader VS
{
    void main()
    {
        o.worldPosition = u_ModelMatrix * vec4(position, 1);
        o.normal = normal; // (u_ModelMatrix * vec4(normal, 0)).xyz;
        o.color = color; // color.aaaa; // temp swizzle of alpha in every color bit for debug
        o.id = gl_VertexID; // Used for crease detection

        vec4 camPos = u_CameraMatrix[3]; 
        
        o.data1.xyz = position;
        
        // NdotV of the vertex
        o.data1.w = dot(u_ModelMatrix * vec4(normal, 0), camPos - o.worldPosition);

        // gl_Position = u_MVPMatrix * vec4(position, 1);
    }
}

GLSLShader GS
{
    layout(triangles_adjacency) in;
    layout(triangle_strip, max_vertices = 32) out;

    float distanceToLine(vec3 point, vec3 a, vec3 b)
    {
        return length(cross(point - a, point - b)) / length(b - a);
    }

    float area(vec3 v0, vec3 v1, vec3 v2) 
    {
        return length(cross(v2 - v0, v2 - v1)) * 0.5;
    }

    vec3 xprime(float di, float dj, vec3 xi, vec3 xj) {
        float L = abs(di) + abs(dj);
        return (abs(dj) / L) * xi + (abs(di) / L) * xj;
    }

    void drawCreaseDebug(vec4 v0, vec4 v1, vec3 n0, vec3 n1)
    {
        vec3 start = v0.xyz + normalize(n0) * 0.01;
        vec3 end = v1.xyz + normalize(n1) * 0.01;
        vec3 right = start + normalize(cross(start - end, n0)) * 0.1;

        gl_Position = u_ViewProjMatrix * vec4(start, 1);
        EmitVertex();

        gl_Position = u_ViewProjMatrix * vec4(end, 1);
        EmitVertex();

        gl_Position = u_ViewProjMatrix * vec4(right, 1);
        EmitVertex();

        EndPrimitive();
    }

    bool isBackface(vec3 v0, vec3 v1, vec3 v2) {
        vec3 N = cross(v1 - v0, v2 - v0);
        vec3 center = (v0 + v1 + v2) / 3;
        return dot(center - u_CameraMatrix[3].xyz, N) >= 0;
    }

    /**
     * Where the vertices are already in clip space
     */
    // void emitQuad(vec2 v[4])
    // {
    //     for (int idx = 0; idx < 4; idx++) {
    //         gl_Position = v[idx];
    //         EmitVertex();
    //     }

    //     EndPrimitive();
    // }

    /**
     * Draw a screen-space (billboarded) arrow pointing 
     * at the given world space position
     */
    void drawVertexMarker(vec4 v) 
    {
        v = u_ViewProjMatrix * v;
        
        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];

        gl_Position = v;
        EmitVertex();

        // add some extra verts for testing
        gl_Position = v + vec4(-0.1 * aspect, 0.1, 0, 0);
        EmitVertex();
        
        gl_Position = v + vec4(0.1 * aspect, 0.1, 0, 0);
        EmitVertex();

        EndPrimitive();
    }

    struct SilhouetteInfo {
        bool valid;
        int permutation;

        vec3 startPos;
        vec3 endPos;
        vec3 startNormal;
        vec3 endNormal;
    };

    /**
     * Calculate silhouette edge information for the input triangle
     */
    SilhouetteInfo getSilhouetteInfo() {
        float L;

        int i0 = 0;
        int i1 = 2;
        int i2 = 4;

        // NdotV values of each vertex
        float d0 = gsin[i0].data1.w;
        float d1 = gsin[i1].data1.w;
        float d2 = gsin[i2].data1.w;

        // Offset NdotV by 0.1 so we always have a nonzero.
        // .: +1 for >= 0, -1 for < 0
        float s0 = sign(d0 + 0.0001);
        float s1 = sign(d1 + 0.0001);
        float s2 = sign(d2 + 0.0001);

        // Local vertex positions
        vec3 v0 = gsin[i0].data1.xyz;
        vec3 v1 = gsin[i1].data1.xyz;
        vec3 v2 = gsin[i2].data1.xyz;

        vec3 n0 = gsin[i0].normal;
        vec3 n1 = gsin[i1].normal;
        vec3 n2 = gsin[i2].normal;

        // Naive method : ALL permutations 

        SilhouetteInfo s;
        s.valid = true;

        if (s0 != s1 && s0 != s2) {
            // start is s2 to s0, end is s2 to s1
            s.permutation = 1;

            // Weighted silhouette points
            s.startPos = xprime(d0, d1, v0, v1);
            s.endPos = xprime(d0, d2, v0, v2);

            // Normal is the interp of the two end normals
            L = distance(v0, s.startPos) / distance(v0, v1);
            s.startNormal = lerp(n0, n1, L);

            L = distance(v0, s.endPos) / distance(v0, v2);
            s.endNormal = lerp(n0, n2, L);
        }
        else if (s1 != s0 && s1 != s2) {
            s.permutation = 2;
            
            s.startPos = xprime(d1, d0, v1, v0);
            s.endPos = xprime(d1, d2, v1, v2);

            L = distance(v1, s.startPos) / distance(v1, v0);
            s.startNormal = lerp(n1, n0, L);

            L = distance(v1, s.endPos) / distance(v1, v2);
            s.endNormal = lerp(n1, n2, L);
        }
        else if (s2 != s0 && s2 != s1) {
            s.permutation = 3;

            s.startPos = xprime(d2, d0, v2, v0);
            s.endPos = xprime(d2, d1, v2, v1);

            L = distance(v2, s.startPos) / distance(v2, v0);
            s.startNormal = lerp(n2, n0, L);

            L = distance(v2, s.endPos) / distance(v2, v1);
            s.endNormal = lerp(n2, n1, L);
        }
        else {
            s.valid = false;
        }

        return s;
    }

    void drawSilhouette(SilhouetteInfo s) {
        // vec3 up = s.endPos - s.startPos;
        // vec3 look = u_CameraMatrix[3].xyz - s.startPos;
        // look.y = 0;
        // look = normalize(look);
        // up = normalize(up);
        // vec3 right = cross(up, look);
        vec3 v[4];
        vec3 camPos = u_CameraMatrix[3].xyz;

        float startScale = u_SilhouetteScale;
        float endScale = u_SilhouetteScale;

        if (u_CreaseViewSpaceScale) {
            startScale *= distance(s.startPos, camPos) * 0.1;
            endScale *= distance(s.endPos, camPos) * 0.1;
        }

        // TODO: ns/ne should NOT be perpendicular to the face normal that we're drawing along.
        // instead, this should be flush with the view space.
        v[0] = vec3(s.startPos + startScale * normalize(s.startNormal));
        v[1] = vec3(s.endPos + endScale * normalize(s.endNormal));
        v[2] = vec3(s.startPos);
        v[3] = vec3(s.endPos);

        o.color = vec4(u_OutlineColor, 0);

        // TODO: Set o.worldNormal for silhouette edges

        // Debug out original facing directions before the flip
        // (red is forward, green is reversed)
        // if (u_Debug) {
        //     if (NdotV > 0) {
        //         o.col = vec4(1, 0, 0, 1);
        //     } else if (NdotV < 0) {
        //         o.col = vec4(0, 1, 0, 1);
        //     }
        // }

        if (!isBackface(v[0], v[1], v[2])) {
            for (int i = 0; i < 4; i++) {
                gl_Position = u_MVPMatrix * vec4(v[i], 1.0);
                EmitVertex();
            }
        } else {
            // Flip winding order of the quad
            gl_Position = u_MVPMatrix * vec4(v[1], 1.0);
            EmitVertex();
            
            gl_Position = u_MVPMatrix * vec4(v[0], 1.0);
            EmitVertex();
            
            gl_Position = u_MVPMatrix * vec4(v[3], 1.0);
            EmitVertex();
            
            gl_Position = u_MVPMatrix * vec4(v[2], 1.0);
            EmitVertex();
        }
        
        EndPrimitive();
    }

    /**
     * Add screen space billboard geometry to represent a crease edge between v0 and v1
     *
     * @param vec4 v0 Start vertex in world space
     * @param vec4 v1 End vertex in world space
     * @param vec3 n0 Start vertex's normal in world space
     * @param vec3 n1 End vertex's normal in world space
     */
    void drawCrease(vec4 v0, vec4 v1, vec3 n0, vec3 n1) {
        vec4 camPos = u_CameraMatrix[3];
        
        float scale0 = u_CreaseScale; 
        float scale1 = u_CreaseScale; 

        // Scale linearly with distance in view space
        if (u_CreaseViewSpaceScale) {
            scale0 *= distance(v0, camPos) * 0.1;
            scale1 *= distance(v1, camPos) * 0.1;
        }

        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];
        float halfW0 = scale0 * 0.5;
        float halfW1 = scale1 * 0.5;

        // Offset crease edge by the source edge's normal direction  
        // scaled by the thickness of the crease we're going to draw.
        // The 0.1 factor is to always keep it intersecting the surface
        // geometry a little bit and not entirely fly off.
        // TODO: This is incorrect - as we should instead perfectly align with the 
        // geometry. Otherwise, intersections cause roundedness within edges.
        // v0 = v0 + vec4(normalize(n0) * u_CreaseScale * 0.1, 0);
        // v1 = v1 + vec4(normalize(n1) * u_CreaseScale * 0.1, 0);

        // Convert points to projected + normalized device coords [-1, 1]
        vec4 p0 = u_ViewProjMatrix * v0;
        vec4 p1 = u_ViewProjMatrix * v1;

        vec2 s0 = p0.xy / p0.w;
        vec2 s1 = p1.xy / p1.w;

        // Push projected z-depth toward the camera
        // can't though - shows geo behind our mesh.
        // p0.z -= 0.1;
        // p1.z -= 0.1;

        // Correct for aspect ratio
        s0.x /= aspect;
        s1.x /= aspect;

        // Generate a right vector perpendicular to our forward direction in NDC
        vec2 forward = normalize(s1 - s0);
        vec2 right = vec2(-forward.y, forward.x);

        // Encode as a generated crease vertex
        // TODO: Distance should be encoded as well instead of in the
        // fragment shader so GL can interp. but fuck it, will do later.
        o.dist = vec4(p0.xy, p1.xy);
        
        vec2 segmentDir = p0.xy - p1.xy;
        segmentDir.x /= aspect;

        float segmentLen = length(segmentDir);
        float uvSegmentLen = segmentLen / (scale1 + segmentLen);
        
        float uvHalfW = (1.0 - uvSegmentLen) * 0.5;

        // color Z channel is screen space segment length
        o.color.z = uvHalfW;

        vec4 aspectCorrect = vec4(aspect, 1, 0, 0);

        // vec4 viewPos = u_ViewMatrix * v0;
        // float depth = -viewPos.z;

        gl_Position = p0 + (vec4(right, 0, 0) * -halfW0 + vec4(forward, 0, 0) * -halfW0) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(0, 0);
        
        // gl_Position.z = p0.z - 0.01;
        EmitVertex();

        gl_Position = p1 + (vec4(right, 0, 0) * -halfW1 + vec4(forward, 0, 0) * halfW1) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(1, 0);
        
        // gl_Position.z = p1.z - 0.01;
        EmitVertex();

        gl_Position = p0 + (vec4(right, 0, 0) * halfW0 + vec4(forward, 0, 0) * -halfW0) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(0, 1);
        
        // gl_Position.z = p0.z - 0.01;
        EmitVertex();
        
        gl_Position = p1 + (vec4(right, 0, 0) * halfW1 + vec4(forward, 0, 0) * halfW1) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(1, 1);
        
        // gl_Position.z = p1.z - 0.01;
        EmitVertex();

        EndPrimitive();
    }

    /**
     * Calculate distance between a vertex and its opposite edge
     *
     * See: Bærentzen, J. A., Munk-Lund, S., Gjøl, M., & Larsen, B. D. (2008). 
     * Two Methods for Antialiased Wireframe Drawing with Hidden Line Removal. 
     * http://orbit.dtu.dk/files/3735323/wire-sccg.pdf
     *
     * @param int idx Vertex index in the GS input
     * 
     * @return vec3
     */
    vec3 getOppositeEdgeDistanceVec(int idx) {
        int nextIdx = (idx + 2) % 6;
        int nextIdx2 = (nextIdx + 2) % 6;

        // Vertex to edge distance calculations for wireframe rendering
        // as part of our fragment coloring (instead of a separate technique)
        vec4 v0 = u_ViewProjMatrix * gsin[idx].worldPosition;
        vec4 v1 = u_ViewProjMatrix * gsin[nextIdx].worldPosition;
        vec4 v2 = u_ViewProjMatrix * gsin[nextIdx2].worldPosition;

        float d = distanceToLine(v0.xyz, v1.xyz, v2.xyz);

        if (idx == 0) {
            return vec3(d, 0, 0);
        } else if (idx == 2) {
            return vec3(0, d, 0);
        } else {
            return vec3(0, 0, d);
        }
    }

    /**
     * Determine if there is a valid crease line between the two input vertices.
     * 
     * Creases are defined by alpha painting the vertex colors as well as the 
     * vertex ID ordering to ensure that the same crease isn't drawn by adjacent
     * triangles that operate on the same edge.
     *
     * Vertex alpha painting may also be different levels to indicate what
     * LOD the crease should be visible within. 
     *
     * This MASSIVELY assumes the vertex indices match winding order.
     *
     * @param int idx Index of crease start vertex in GS inputs
     * @param int nextIdx Index of crease end vertex in GS inputs
     * @param int lod Current LOD to check against
     *
     * @return boolean
     */
    bool isValidCrease(int idx, int nextIdx, int lod) {
        // TODO: less hardcoding.
        float low = 0.10; // LOD0 - 0.1X
        float high = 0.19;

        if (lod == 1) { // LOD1 - 0.2X
            low = 0.20;
            high = 0.29;
        } else if (lod == 2) { // LOD2 - 0.3X
            low = 0.30;
            high = 0.39;
        }

        float a = gsin[idx].color.a;
        float b = gsin[nextIdx].color.a;

        // Get lower end of the vertex LOD (0.10, 0.20, 0.30)
        float al = floor(a * 10) / 10;
        float bl = floor(b * 10) / 10;
        
        // Increasing vertex IDs, both at *least* the 
        // input LOD, *and* one of them is an exact 
        // crease vertex (0.X0)
        return (gsin[idx].id < gsin[nextIdx].id) &&
            (a >= low && b >= low) &&
            (abs(a - al) < EPSILON ||
            abs(b - bl) < EPSILON);
    }

    /**
     * Draw the base triangle input
     */
    void drawInputGeometry()
    {
        // triadj - 0, 2, 4 indices
        for (int idx = 0; idx < 6; idx += 2) {
            // Color without the type encoding
            // o.color = vec4(gsin[idx].color.rgb, 0);
            o.color = vec4(0.5, 0.5, 0.5, 0);
            o.worldNormal = (u_ModelMatrix * vec4(gsin[idx].normal, 0)).xyz;
            o.worldPosition = gsin[idx].worldPosition;

            // vec4 viewPos = u_ViewMatrix * o.worldPosition;
            // float depth = -viewPos.z;

            // Calculate opposite edge distance per vertex for wireframing
            o.dist = vec4(getOppositeEdgeDistanceVec(idx), 0);

            // o.color = vec4(vec3(depth), 0);
            gl_Position = u_ViewProjMatrix * o.worldPosition;
            // gl_Position.z = depth;
            EmitVertex();
        }

        EndPrimitive();
    }

    /**
     * Retrieve LOD of the current model
     */
    int getLOD() {
        vec4 origin = u_ModelMatrix * vec4(0, 0, 0, 1);
        float d = distance(u_CameraMatrix[3], origin);

        int lod = 0;
        if (d > u_LOD2Distance) {
            lod = 2;
        } else if (d > u_LOD1Distance) {
            lod = 1;
        }

        return lod;
    }

    void main()
    {
        if (u_GeometryDrawMode > 0) {
            drawInputGeometry();
        }

        // Don't calculate creases if we're a backface triangle
        if (u_CullBackfaceCreases && 
            isBackface(
                gsin[0].worldPosition.xyz, 
                gsin[1].worldPosition.xyz,
                gsin[2].worldPosition.xyz
            )
        ) {
            return;
        }

        if (u_SilhouetteDrawMode > 0) {
            SilhouetteInfo s = getSilhouetteInfo();
            if (s.valid) {
                // drawSilhouette(s);

                // Copy color forward to silhouette geometry.
                // And set alpha to < 0.2 for detection in the PS
                o.color = gsin[0].color;
                o.color.a = 0.1;

                drawCrease(
                    u_ModelMatrix * vec4(s.startPos, 1), 
                    u_ModelMatrix * vec4(s.endPos, 1), 
                    vec3(0), vec3(0)
                );
            }
        }

        if (u_CreaseDrawMode < 1) {
            return;
        }

        // If the entire triangle is marked with crease edges, ignore entirely.
        // It's at a junction we can't resolve.
        // if (gsin[0].color.a == gsin[2].color.a && gsin[0].color.a == gsin[4].color.a) {
        //     return;
        // }
        
        int lod = getLOD();

        // For every crease edge, draw a billboarded prismoid
        for (int idx = 0; idx < 6; idx += 2) {
            int nextIdx = (idx + 2) % 6;

            // Copy forward to all crease geometry
            o.color = gsin[idx].color;

            if (isValidCrease(idx, nextIdx, lod)) {
                drawCrease(
                    gsin[idx].worldPosition, 
                    gsin[nextIdx].worldPosition,
                    gsin[idx].normal, 
                    gsin[nextIdx].normal
                );
            }
        }
    }
}


GLSLShader PS
{
    float distanceToSegment(vec2 point, vec2 a, vec2 b) 
    {
        float dist = length(a - b);
        vec2 v = normalize(b - a);
        float t = dot(v, point - a);

        // Determine which is the closest point to measure
        // distance from - either an endpoint or an interpolation
        // somewhere in the middle
        vec2 spinePoint;
        if (t > dist) {
            spinePoint = b;
        } else if (t > 0.0) {
            spinePoint = a + t * v;
        } else {
            spinePoint = a;
        }

        return length(point - spinePoint);
    }

    void main()
    {
        float d;

        // If alpha channel is nonzero, we're flagged as crease/silhouette geometry
        if (i.color.a > 0.001) {
            // Extract UV coordinates and edge half width from color
            vec2 uv = i.color.rg;
            float uvHalfW = i.color.b;
            uv.y *= uvHalfW * 2;

            // Generate a screen-space capsule by discarding fragments
            // that are further than uvHalfW from the crease edge
            vec2 start = vec2(uvHalfW, uvHalfW);
            vec2 end = vec2(1.0 - uvHalfW, uvHalfW);

            d = distanceToSegment(uv, start, end);
            if (d > uvHalfW) {
                discard;
            }

            bool isSilhouette = i.color.a < 0.20;

            // Compute final color for crease geometry
            if (isSilhouette && u_SilhouetteDrawMode == SILHOUETTE_DRAW_UVS) {
                color.rgb = vec3(uv.x, 0, uv.y);
            } else if (!isSilhouette && u_CreaseDrawMode == CREASE_DRAW_UVS) {
                color.rgb = vec3(uv.x, 0, uv.y);
            }
            
            // Color creases by LOD (not supported by silhouettes yet)
            if (!isSilhouette && u_CreaseDrawMode == CREASE_DRAW_LOD) {
                if (i.color.a < 0.2) { //  LOD0 - White
                    color.rgb = vec3(1);
                } else if (i.color.a < 0.3) { // LOD1 - Grey
                    color.rgb = vec3(0.25);
                } else { // LOD2 - Dark Grey
                    color.rgb = vec3(0.01);
                }
            }

            if (isSilhouette && u_SilhouetteDrawMode == SILHOUETTE_DRAW_COLOR) {
                color.rgb = u_OutlineColor;
            } else if (!isSilhouette && u_CreaseDrawMode == CREASE_DRAW_COLOR) {
                color.rgb = u_OutlineColor;
            }

        } else {
            color.rgb = u_Diffuse;
            
            // Wireframe rendering by lerping between a wireframe 
            // color and our actual output color based on how close the
            // fragment is to a triangle edge
            if (u_GeometryDrawMode == GEOMETRY_DRAW_WIREFRAME) {
                d = min(i.dist.x, min(i.dist.y, i.dist.z)) * 1.0;
                float intensity = exp2(-2.0 * d * d);

                // width should probably be some factor of distance, but whatever.
                d = smoothstep(0.025, 0.05, d);

                // draw the main color, but fade vertex edges on top of it
                // TODO: Distance based
                color.rgb = lerp(color.rgb, d * color.rgb, 0.1);
            }
        }
    }
}

technique Main
<
    string Transparency = "Opaque";
    // string Transparency = "Transparent";
    string index_buffer_type = "GLSL_TRIADJ";
>
{
	pass p0
	{
		VertexShader (in appdata, out vs_to_gs o) = VS;
		GeometryShader (in vs_to_gs gsin, out gs_to_ps o) = GS;
		PixelShader (in gs_to_ps i, out ps_out) = PS;
	}
}
