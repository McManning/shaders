#version 410

#include "Utility.ogsfh"
#include "Settings.ogsfh"

attribute appdata {
    vec3 position : POSITION;
	vec3 normal : NORMAL;
    vec4 color : COLOR0;
};
 
attribute vs_to_gs {
    vec4 worldPosition : POSITION;
	vec3 worldNormal : NORMAL;
    vec4 color : TEXCOORD0;
    int id : TEXCOORD2;
};

attribute gs_to_ps {
    vec4 worldPosition : POSITION;
	vec3 worldNormal : NORMAL;
    vec4 color : TEXCOORD0;

    // encoded data, meaning changes based on the generator of the vertex.
    // color.a defines the encoding (normal face, silhouette, crease)
    // normal face: xyz is the distance to the opposite edge (for wireframe drawing)
    // silhouette: TBD
    // crease: xy is the crease edge start position, zw is end position
    // vec4 encoded : TEXCOORD1;
    vec4 dist: TEXCOORD1;
};

attribute ps_out {
    vec4 color : TEXCOORD0;
};

GLSLShader VS
{
    void main()
    {
        o.worldPosition = u_ModelMatrix * vec4(position, 1);
        o.worldNormal = normal; // (u_ModelMatrix * vec4(normal, 0)).xyz;
        o.color = color; // color.aaaa; // temp swizzle of alpha in every color bit for debug
        o.id = gl_VertexID; // Used for crease detection

        // gl_Position = u_MVPMatrix * vec4(position, 1);
    }
}

// Wireframing geometry shader from Maya's example code.
// Used in the Wireframe technique to check tessellation / etc
GLSLShader GS_Wireframe
{
    layout(triangles_adjacency) in;
    layout(triangle_strip, max_vertices = 32) out;

    /**
     * Emit a vertex that is in world space
     */
    void emit(vec3 v) {
        gl_Position = u_ViewProjMatrix * vec4(v, 1);
        EmitVertex();
    }

    float distanceToLine(vec3 point, vec3 a, vec3 b)
    {
        return length(cross(point - a, point - b)) / length(b - a);
    }

    float distanceToSegment(vec2 point, vec2 a, vec2 b) 
    {
        float dist = length(a - b);
        vec2 v = normalize(b - a);
        float t = dot(v, point - a);

        // TODO: Simplify later. Resolve against distanceToLine
        vec2 spinePoint;
        if (t > dist) {
            spinePoint = b;
        } else if (t > 0.0) {
            spinePoint = a + t * v;
        } else {
            spinePoint = a;
        }

        return length(point - spinePoint);
    }

    float area(vec3 v0, vec3 v1, vec3 v2) 
    {
        return length(cross(v2 - v0, v2 - v1)) * 0.5;
    }

    void drawCreaseDebug(vec4 v0, vec4 v1, vec3 n0, vec3 n1)
    {
        vec3 start = v0.xyz + normalize(n0) * 0.01;
        vec3 end = v1.xyz + normalize(n1) * 0.01;
        vec3 right = start + normalize(cross(start - end, n0)) * 0.1;

        gl_Position = u_ViewProjMatrix * vec4(start, 1);
        EmitVertex();

        gl_Position = u_ViewProjMatrix * vec4(end, 1);
        EmitVertex();

        gl_Position = u_ViewProjMatrix * vec4(right, 1);
        EmitVertex();

        EndPrimitive();
    }

    bool isBackface(vec3 v0, vec3 v1, vec3 v2) {
        vec3 N = cross(v1 - v0, v2 - v0);
        return dot(u_CameraMatrix[3].xyz - v0, N) < 0;
    }

    /**
     * Where the vertices are already in clip space
     */
    // void emitQuad(vec2 v[4])
    // {
    //     for (int idx = 0; idx < 4; idx++) {
    //         gl_Position = v[idx];
    //         EmitVertex();
    //     }

    //     EndPrimitive();
    // }

    /**
     * Draw a screen-space (billboarded) arrow pointing 
     * at the given world space position
     */
    void drawVertexMarker(vec4 v) 
    {
        v = u_ViewProjMatrix * v;
        
        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];

        gl_Position = v;
        EmitVertex();

        // add some extra verts for testing
        gl_Position = v + vec4(-0.1 * aspect, 0.1, 0, 0);
        EmitVertex();
        
        gl_Position = v + vec4(0.1 * aspect, 0.1, 0, 0);
        EmitVertex();

        EndPrimitive();
    }

    /**
     * Add screen space billboard geometry to represent a crease edge between v0 and v1
     *
     * @param vec4 v0 Start vertex in world space
     * @param vec4 v1 End vertex in world space
     * @param vec3 n0 Start vertex's normal in world space
     * @param vec3 n1 End vertex's normal in world space
     */
    void drawCrease(vec4 v0, vec4 v1, vec3 n0, vec3 n1)
    {
        vec4 camPos = u_CameraMatrix[3];
        
        // Scale linearly with distance
        float scale0 = u_CreaseScale * distance(v0, camPos) * 0.1;
        float scale1 = u_CreaseScale * distance(v1, camPos) * 0.1;

        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];
        float halfW0 = scale0 * 0.5;
        float halfW1 = scale1 * 0.5;

        // Offset crease edge by the source edge's normal direction  
        // scaled by the thickness of the crease we're going to draw.
        // The 0.1 factor is to always keep it intersecting the surface
        // geometry a little bit and not entirely fly off.
        // TODO: This is incorrect - as we should instead perfectly align with the 
        // geometry. Otherwise, intersections cause roundedness within edges.
        // v0 = v0 + vec4(normalize(n0) * u_CreaseScale * 0.1, 0);
        // v1 = v1 + vec4(normalize(n1) * u_CreaseScale * 0.1, 0);

        // Convert points to projected + normalized device coords [-1, 1]
        vec4 p0 = u_ViewProjMatrix * v0;
        vec4 p1 = u_ViewProjMatrix * v1;

        vec2 s0 = p0.xy / p0.w;
        vec2 s1 = p1.xy / p1.w;

        // Push projected z-depth toward the camera
        // can't though - shows geo behind our mesh.
        // p0.z -= 0.1;
        // p1.z -= 0.1;

        // Correct for aspect ratio
        s0.x /= aspect;
        s1.x /= aspect;

        // Generate a right vector perpendicular to our forward direction in NDC
        vec2 forward = normalize(s1 - s0);
        vec2 right = vec2(-forward.y, forward.x);

        // Encode as a generated crease vertex
        // TODO: Distance should be encoded as well instead of in the
        // fragment shader so GL can interp. but fuck it, will do later.
        o.dist = vec4(p0.xy, p1.xy);
        o.color = vec4(1, 0, 1, 1);
        
        vec2 segmentDir = p0.xy - p1.xy;
        segmentDir.x /= aspect;

        float segmentLen = length(segmentDir);
        float uvSegmentLen = segmentLen / (scale1 + segmentLen);
        
        float uvHalfW = (1.0 - uvSegmentLen) * 0.5;

        // color Z channel is screen space segment length
        o.color.z = uvHalfW;

        vec4 aspectCorrect = vec4(aspect, 1, 0, 0);

        // vec4 viewPos = u_ViewMatrix * v0;
        // float depth = -viewPos.z;

        gl_Position = p0 + (vec4(right, 0, 0) * -halfW0 + vec4(forward, 0, 0) * -halfW0) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(0, 0);
        
        // gl_Position.z = p0.z - 0.01;
        EmitVertex();

        gl_Position = p1 + (vec4(right, 0, 0) * -halfW1 + vec4(forward, 0, 0) * halfW1) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(1, 0);
        
        // gl_Position.z = p1.z - 0.01;
        EmitVertex();

        gl_Position = p0 + (vec4(right, 0, 0) * halfW0 + vec4(forward, 0, 0) * -halfW0) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(0, 1);
        
        // gl_Position.z = p0.z - 0.01;
        EmitVertex();
        
        gl_Position = p1 + (vec4(right, 0, 0) * halfW1 + vec4(forward, 0, 0) * halfW1) * aspectCorrect;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        o.color.xy = vec2(1, 1);
        
        // gl_Position.z = p1.z - 0.01;
        EmitVertex();

        EndPrimitive();
    }

    /**
     * Calculate distance between a vertex and its opposite edge
     *
     * See: Bærentzen, J. A., Munk-Lund, S., Gjøl, M., & Larsen, B. D. (2008). 
     * Two Methods for Antialiased Wireframe Drawing with Hidden Line Removal. 
     * http://orbit.dtu.dk/files/3735323/wire-sccg.pdf
     *
     * @param int idx Vertex index in the GS input
     * 
     * @return vec3
     */
    vec3 getOppositeEdgeDistanceVec(int idx) {
        int nextIdx = (idx + 2) % 6;
        int nextIdx2 = (nextIdx + 2) % 6;

        // Vertex to edge distance calculations for wireframe rendering
        // as part of our fragment coloring (instead of a separate technique)
        vec4 v0 = u_ViewProjMatrix * input[idx].worldPosition;
        vec4 v1 = u_ViewProjMatrix * input[nextIdx].worldPosition;
        vec4 v2 = u_ViewProjMatrix * input[nextIdx2].worldPosition;

        float d = distanceToLine(v0.xyz, v1.xyz, v2.xyz);

        if (idx == 0) {
            return vec3(d, 0, 0);
        } else if (idx == 2) {
            return vec3(0, d, 0);
        } else {
            return vec3(0, 0, d);
        }
    }

    /**
     * Determine if there is a valid crease line between the two input vertices.
     * 
     * Creases are defined by alpha painting the vertex colors as well as the 
     * vertex ID ordering to ensure that the same crease isn't drawn by adjacent
     * triangles that operate on the same edge.
     *
     * This MASSIVELY assumes the vertex indices match winding order.
     *
     * @param int idx Index of crease start vertex in GS inputs
     * @param int nextIdx Index of crease end vertex in GS inputs
     *
     * @return boolean
     */
    bool isValidCrease(int idx, int nextIdx) {
        return input[idx].id < input[nextIdx].id &&
                input[idx].color.a > 0.99 && input[nextIdx].color.a > 0.99;
    }

    /**
     * Draw the base triangle input
     */
    void drawInputGeometry()
    {
        // triadj - 0, 2, 4 indices
        for (int idx = 0; idx < 6; idx += 2) {
            // Color without the type encoding
            // o.color = vec4(input[idx].color.rgb, 0);
            o.color = vec4(0.5, 0.5, 0.5, 0);
            o.worldNormal = input[idx].worldNormal;
            o.worldPosition = input[idx].worldPosition;

            // vec4 viewPos = u_ViewMatrix * o.worldPosition;
            // float depth = -viewPos.z;

            // Calculate opposite edge distance per vertex for wireframing
            o.dist = vec4(getOppositeEdgeDistanceVec(idx), 0);

            // o.color = vec4(vec3(depth), 0);
            gl_Position = u_ViewProjMatrix * o.worldPosition;
            // gl_Position.z = depth;
            EmitVertex();
        }

        EndPrimitive();
    }

    void main()
    {
        drawInputGeometry();

        // Don't calculate creases if we're a backface triangle
        if (u_CullBackfaceCreases && 
            isBackface(
                input[0].worldPosition.xyz, 
                input[1].worldPosition.xyz,
                input[2].worldPosition.xyz
            )
        ) {
            return;
        }

        // If the entire triangle is marked with crease edges, ignore entirely.
        // It's at a junction we can't resolve.
        if (input[0].color.a == input[2].color.a && input[0].color.a == input[4].color.a) {
            return;
        }
        
        // For every crease edge, draw a billboarded prismoid
        for (int idx = 0; idx < 6; idx += 2) {
            int nextIdx = (idx + 2) % 6;

            if (isValidCrease(idx, nextIdx)) {
                drawCrease(
                    input[idx].worldPosition, 
                    input[nextIdx].worldPosition,
                    input[idx].worldNormal, 
                    input[nextIdx].worldNormal
                );
            }
        }
    }
}


GLSLShader PS
{
    float distanceToSegment(vec2 point, vec2 a, vec2 b) 
    {
        float dist = length(a - b);
        vec2 v = normalize(b - a);
        float t = dot(v, point - a);

        // Determine which is the closest point to measure
        // distance from - either an endpoint or an interpolation
        // somewhere in the middle
        vec2 spinePoint;
        if (t > dist) {
            spinePoint = b;
        } else if (t > 0.0) {
            spinePoint = a + t * v;
        } else {
            spinePoint = a;
        }

        return length(point - spinePoint);
    }

    void main()
    {
        float d;

        // If alpha channel is nonzero, we're flagged as crease geometry
        if (i.color.a > 0.0001) {
            // // decode segment line from color, worldpos is actually screen pos in this case
            d = distanceToSegment(i.worldPosition.xy, i.dist.xy, i.dist.zw);

            // Extract UV coordinates and edge half width from color
            vec2 uv = i.color.rg;
            float uvHalfW = i.color.b;
            uv.y *= uvHalfW * 2;

            // Generate a screen-space capsule by discarding fragments
            // that are further than uvHalfW from the crease edge
            vec2 start = vec2(uvHalfW, uvHalfW);
            vec2 end = vec2(1.0 - uvHalfW, uvHalfW);

            d = distanceToSegment(uv, start, end);
            if (d > uvHalfW) {
                discard;
            }

            // Compute final color for crease geometry
            color.rgb = vec3(uv.x, 0, uv.y);
        } else {
            discard;

            // Wireframe rendering by lerping between a wireframe 
            // color and our actual output color based on how close the
            // fragment is to a triangle edge
            d = min(i.dist.x, min(i.dist.y, i.dist.z)) * 1.0;
            float intensity = exp2(-2.0 * d * d);

            // width should probably be some factor of distance, but whatever.
            d = smoothstep(0.025, 0.05, d);

            // draw the main color, but fade vertex edges on top of it
            color = lerp(i.color, d * i.color, 0.1);
        }
    }
}

technique Main
<
    string Transparency = "Opaque";
    // string Transparency = "Transparent";
    string index_buffer_type = "GLSL_TRIADJ";
>
{
	pass p0
	{
		VertexShader (in appdata, out vs_to_gs o) = VS;
		GeometryShader (in vs_to_gs input, out gs_to_ps o) = GS_Wireframe;
		PixelShader (in gs_to_ps i, out ps_out) = PS;
	}
}
