#version 410

#include "Utility.ogsfh"
#include "Settings.ogsfh"

attribute appdata {
    vec3 position : POSITION;
	vec3 normal : NORMAL;
    vec4 color : COLOR0;
};
 
attribute vs_to_gs {
    vec4 worldPosition : POSITION;
	vec3 worldNormal : NORMAL;
    vec4 color : TEXCOORD0;
    int id : TEXCOORD2;
};

attribute gs_to_ps {
    vec4 worldPosition : POSITION;
	vec3 worldNormal : NORMAL;
    vec4 color : TEXCOORD0;

    // encoded data, meaning changes based on the generator of the vertex.
    // color.a defines the encoding (normal face, silhouette, crease)
    // normal face: xyz is the distance to the opposite edge (for wireframe drawing)
    // silhouette: TBD
    // crease: xy is the crease edge start position, zw is end position
    // vec4 encoded : TEXCOORD1;
    vec4 dist: TEXCOORD1;
};

attribute ps_out {
    vec4 color : TEXCOORD0;
};

GLSLShader VS
{
    void main()
    {
        o.worldPosition = u_ModelMatrix * vec4(position, 1);
        o.worldNormal = normal; // (u_ModelMatrix * vec4(normal, 0)).xyz;
        o.color = color; // color.aaaa; // temp swizzle of alpha in every color bit for debug
        o.id = gl_VertexID; // Used for crease detection

        // gl_Position = u_MVPMatrix * vec4(position, 1);
    }
}

// Wireframing geometry shader from Maya's example code.
// Used in the Wireframe technique to check tessellation / etc
GLSLShader GS_Wireframe
{
    layout(triangles_adjacency) in;
    layout(triangle_strip, max_vertices = 32) out;

    /**
     * Emit a vertex that is in world space
     */
    void emit(vec3 v) {
        gl_Position = u_ViewProjMatrix * vec4(v, 1);
        EmitVertex();
    }

    float distanceToLine(vec3 point, vec3 a, vec3 b)
    {
        return length(cross(point - a, point - b)) / length(b - a);
    }

    float distanceToSegment(vec2 point, vec2 a, vec2 b) 
    {
        float dist = length(a - b);
        vec2 v = normalize(b - a);
        float t = dot(v, point - a);

        // TODO: Simplify later. Resolve against distanceToLine
        vec2 spinePoint;
        if (t > dist) {
            spinePoint = b;
        } else if (t > 0.0) {
            spinePoint = a + t * v;
        } else {
            spinePoint = a;
        }

        return length(point - spinePoint);
    }

    float area(vec3 v0, vec3 v1, vec3 v2) 
    {
        return length(cross(v2 - v0, v2 - v1)) * 0.5;
    }

    void drawCreaseDebug(vec4 v0, vec4 v1, vec3 n0, vec3 n1)
    {
        vec3 start = v0.xyz + normalize(n0) * 0.01;
        vec3 end = v1.xyz + normalize(n1) * 0.01;
        vec3 right = start + normalize(cross(start - end, n0)) * 0.1;

        gl_Position = u_ViewProjMatrix * vec4(start, 1);
        EmitVertex();

        gl_Position = u_ViewProjMatrix * vec4(end, 1);
        EmitVertex();

        gl_Position = u_ViewProjMatrix * vec4(right, 1);
        EmitVertex();

        EndPrimitive();
    }

    /**
     * Where the vertices are already in clip space
     */
    // void emitQuad(vec2 v[4])
    // {
    //     for (int idx = 0; idx < 4; idx++) {
    //         gl_Position = v[idx];
    //         EmitVertex();
    //     }

    //     EndPrimitive();
    // }

    /**
     * Draw a screen-space (billboarded) arrow pointing 
     * at the given world space position
     */
    void drawVertexMarker(vec4 v) 
    {
        v = u_ViewProjMatrix * v;
        
        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];

        gl_Position = v;
        EmitVertex();

        // add some extra verts for testing
        gl_Position = v + vec4(-0.1 * aspect, 0.1, 0, 0);
        EmitVertex();
        
        gl_Position = v + vec4(0.1 * aspect, 0.1, 0, 0);
        EmitVertex();

        EndPrimitive();
    }

    /*void drawCrease(vec4 v0, vec4 v1, vec4 prev, vec4 next)
    {
        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];

        // Convert points to projected + normalized device coords [-1, 1]
        vec4 p0 = u_ViewProjMatrix * (v0); // + vec4(0.01, 0.01, 0.01, 1));
        vec4 p1 = u_ViewProjMatrix * (v1); // + vec4(normalize(n1) * 0.1, 1));
        vec4 pPrev = u_ViewProjMatrix * prev;
        vec4 pNext = u_ViewProjMatrix * next;
        vec2 s0 = p0.xy / p0.w;
        vec2 s1 = p1.xy / p1.w;
        vec2 sPrev = prev.xy / prev.w;
        vec2 sNext = next.xy / next.w;

        // // Correct for aspect ratio
        // p0.x /= aspect;
        // p1.x /= aspect;

        // Generate a normal perpendicular to our direction in NDC
        // vec2 dir = normalize(s1 - s0);

        // Averaged direction between the two edges across v0 in screen space
        vec2 dir0 = normalize(v1 - prev);
        vec2 dir1 = normalize(next - v0);

        vec2 n0 = normalize(vec2(-dir0.y, dir0.x));
        vec2 n1 = normalize(vec2(-dir1.y, dir1.x));

        // Extrude from the center
        float thickness = 0.08;
        n0 *= thickness * 0.5;
        n1 *= thickness * 0.5;
        // normal.x *= aspect;

        // gl_Position = p0;
        // EmitVertex();

        // add some extra verts for testing
        // gl_Position = p0 + vec4(-0.1 * aspect, 0.1, 0, 0);
        
        gl_Position = p0 + vec4(n0 * -1, 0, 0);
        EmitVertex();

        gl_Position = p1 + vec4(n1 * -1, 0, 0);
        EmitVertex();

        gl_Position = p0 + vec4(n0, 0, 0);
        EmitVertex();
        
        gl_Position = p1 + vec4(n1, 0, 0);
        EmitVertex();

        EndPrimitive();
    }*/

    void drawCrease(vec4 v0, vec4 v1, vec3 wn0, vec3 wn1)
    {
        // Extract aspect ratio from the projection matrix
        // where m00 = 1/(aspect * tan(FOV / 2)) and m11 = 1/tan(FOV / 2)
        float aspect = u_ProjMatrix[0][0] / u_ProjMatrix[1][1];

        // Offset original edge by their normal direction scaled 
        // by the thickness of the crease we're going to draw.
        // The 0.1 factor is to always keep it intersecting the surface
        // geometry a little bit and not entirely fly off.
        v0 = v0 + vec4(normalize(wn0) * u_CreaseScale * 0.1, 0);
        v1 = v1 + vec4(normalize(wn1) * u_CreaseScale * 0.1, 0);

        // Convert points to projected + normalized device coords [-1, 1]
        vec4 p0 = u_ViewProjMatrix * v0;
        vec4 p1 = u_ViewProjMatrix * v1;
        // vec4 pPrev = u_ViewProjMatrix * prev;
        // vec4 pNext = u_ViewProjMatrix * next;
        vec2 s0 = p0.xy / p0.w;
        vec2 s1 = p1.xy / p1.w;
        // vec2 sPrev = prev.xy / prev.w;
        // vec2 sNext = next.xy / next.w;

        // Generate a normal perpendicular to our direction in NDC
        vec2 dir = normalize(s1 - s0);
        vec2 normal = normalize(vec2(-dir.y, dir.x));

        // Extrude from the center
        float thickness = u_CreaseScale;
        normal *= thickness * 0.5;

        // Correct for aspect ratio
        normal.x *= aspect;

        // offset start/end vertices by thickness
        vec4 jv0 = (v0 - normalize(v1 - v0) * u_CreaseScale);
        vec4 jv1 = (v1 + normalize(v1 - v0) * u_CreaseScale);

        vec4 jp0 = u_ViewProjMatrix * (v0);
        vec4 jp1 = u_ViewProjMatrix * (v1);

        // gl_Position = p0;
        // EmitVertex();

        // add some extra verts for testing
        // gl_Position = p0 + vec4(-0.1 * aspect, 0.1, 0, 0);

        // Encode as a generated crease vertex
        // TODO: Distance should be encoded as well instead of in the
        // fragment shader so GL can interp. but fuck it, will do later.

        o.dist = vec4(p0.xy, p1.xy);
        o.color = vec4(1, 0, 1, 1);

        gl_Position = jp0 + vec4(normal, 0, 0) * -1 + vec4(normal.y, -normal.x, 0, 0) * -1;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        // o.color = vec4(distanceToLine(gl_Position.xyz, p0.xyz, p1.xyz), 0, 0, 1);
        EmitVertex();

        gl_Position = jp1 + vec4(normal, 0, 0) * -1 + vec4(normal.y, -normal.x, 0, 0);
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        // o.color = vec4(distanceToLine(gl_Position.xyz, p0.xyz, p1.xyz), 0, 0, 1);
        EmitVertex();

        gl_Position = jp0 + vec4(normal, 0, 0) + vec4(normal.y, -normal.x, 0, 0) * -1;
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        // o.color = vec4(distanceToLine(gl_Position.xyz, p0.xyz, p1.xyz), 0, 0, 1);
        EmitVertex();
        
        gl_Position = jp1 + vec4(normal, 0, 0) + vec4(normal.y, -normal.x, 0, 0);
        o.worldPosition = vec4(gl_Position.xy, 0, 1);
        // o.color = vec4(distanceToLine(gl_Position.xyz, p0.xyz, p1.xyz), 0, 0, 1);
        EmitVertex();

        EndPrimitive();
    }

    vec3 getOppositeEdgeDistanceVec(int idx) {
        int nextIdx = (idx + 2) % 6;
        int nextIdx2 = (nextIdx + 2) % 6;

        // Vertex to edge distance calculations for wireframe rendering
        // as part of our fragment coloring (instead of a separate technique)
        vec4 v0 = u_ViewProjMatrix * input[idx].worldPosition;
        vec4 v1 = u_ViewProjMatrix * input[nextIdx].worldPosition;
        vec4 v2 = u_ViewProjMatrix * input[nextIdx2].worldPosition;

        float d = distanceToLine(v0.xyz, v1.xyz, v2.xyz);

        if (idx == 0) {
            return vec3(d, 0, 0);
        } else if (idx == 2) {
            return vec3(0, d, 0);
        } else {
            return vec3(0, 0, d);
        }
    }

    /**
     * Determine if there is a valid crease line between the two input vertices.
     * 
     * Creases are defined by alpha painting the vertex colors as well as the 
     * vertex ID ordering to ensure that the same crease isn't drawn by adjacent
     * triangles that operate on the same edge.
     *
     * This MASSIVELY assumes the vertex indices match winding order. **
     */
    bool isValidCrease(int idx, int nextIdx) {
        // return input[idx].color.a > 0.99 && input[nextIdx].color.a > 0.99;
        return input[idx].id < input[nextIdx].id &&
                input[idx].color.a > 0.99 && input[nextIdx].color.a > 0.99;
    }

    void main()
    {
        // bool strip_flip = (bool (gl_PrimitiveIDIn & 1));

        // triadj - 0, 2, 4 indices
        for (int idx = 0; idx < 6; idx += 2) {
            // Color without the type encoding
            o.color = vec4(input[idx].color.rgb, 0);
            o.worldNormal = input[idx].worldNormal;
            o.worldPosition = input[idx].worldPosition;
            o.dist = vec4(getOppositeEdgeDistanceVec(idx), 0);

            gl_Position = u_ViewProjMatrix * o.worldPosition;
            EmitVertex();
        }

        EndPrimitive();

        // If the entire triangle is marked with crease edges, ignore entirely.
        // It's at a junction we can't resolve.
        if (input[0].color.a == input[2].color.a && input[0].color.a == input[4].color.a) {
            return;
        }
        
        // For every crease edge, draw a prismoid
        for (int idx = 0; idx < 6; idx += 2) {
            int nextIdx = (idx + 2) % 6;
            int nextIdx2 = (nextIdx + 2) % 6;

            if (isValidCrease(idx, nextIdx)) {
                // if (input[idx].id < input[nextIdx].id) {
                //     o.color = vec4(0, 0.2, 0, 1);
                // } else if (input[idx].id == input[nextIdx].id) {
                //     o.color = vec4(1, 0, 1, 1);
                // } else {
                //     o.color = vec4(0.2, 0, 0, 1);
                // }

                drawCrease(
                    input[idx].worldPosition, 
                    input[nextIdx].worldPosition,
                    input[idx].worldNormal, 
                    input[nextIdx].worldNormal
                );
            }
        }
    }

    void mainx()
    {
        o.color = vec4(0.25, 0, 0, 0);
        // o.color = input[0].color;
        gl_Position = vec4(0, 0, 0, 1); // u_ViewProjMatrix * input[0].worldPosition;
        EmitVertex();

        // o.color = input[1].color;
        gl_Position = vec4(0, 0, 0, 1); // u_ViewProjMatrix * input[1].worldPosition;
        EmitVertex();

        EndPrimitive();

        o.color = vec4(0, 0.25, 0, 0);
        // o.color = input[1].color;
        gl_Position = u_ViewProjMatrix * input[1].worldPosition;
        EmitVertex();

        // o.color = input[2].color;
        gl_Position = u_ViewProjMatrix * input[2].worldPosition;
        EmitVertex();

        EndPrimitive();

        o.color = vec4(0, 0, 0.25, 0);
        // o.color = input[2].color;
        gl_Position = u_ViewProjMatrix * input[2].worldPosition;
        EmitVertex();

        // o.color = input[0].color;
        gl_Position = u_ViewProjMatrix * input[0].worldPosition;
        EmitVertex();

        EndPrimitive();

        // if (input[0].color.a > 0.99 && input[1].color.a > 0.99) {
        //     drawCrease(
        //         input[0].worldPosition, 
        //         input[1].worldPosition, 
        //         input[0].worldNormal,
        //         input[1].worldNormal
        //     );
        // } else if (input[1].color.a > 0.99 && input[2].color.a > 0.99) {
        //     drawCrease(
        //         input[1].worldPosition, 
        //         input[2].worldPosition, 
        //         input[1].worldNormal,
        //         input[2].worldNormal
        //     );
        // } else if (input[2].color.a > 0.99 && input[0].color.a > 0.99) {
        //     drawCrease(
        //         input[2].worldPosition, 
        //         input[0].worldPosition, 
        //         input[2].worldNormal,
        //         input[0].worldNormal
        //     );
        // }

        o.color = vec4(0, 0, 1, 0);

        // gl_Position = u_ViewProjMatrix * (input[0].worldPosition + normalize(vec4(input[0].worldNormal, 0.0)) * 0.03);
        // EmitVertex();

        // gl_Position = u_ViewProjMatrix * (input[1].worldPosition + normalize(vec4(input[1].worldNormal, 0.0)) * 0.03);
        // EmitVertex();

        // EndPrimitive();

    }
}


GLSLShader PS
{
    
    float distanceToSegment(vec2 point, vec2 a, vec2 b) 
    {
        float dist = length(a - b);
        vec2 v = normalize(b - a);
        float t = dot(v, point - a);

        // Determine which is the closest point to measure
        // distance from - either an endpoint or an interpolation
        // somewhere in the middle
        vec2 spinePoint;
        if (t > dist) {
            spinePoint = b;
        } else if (t > 0.0) {
            spinePoint = a + t * v;
        } else {
            spinePoint = a;
        }

        return length(point - spinePoint);
    }

    void main()
    {
        // if (i.color.a > 0.99) {
        //     color = vec4(i.color.a, 0, 0, 1);
        // } else {
            color = vec4(i.color.rgb, 1);
        // }

        // Wireframe rendering, lerping between the wireframe 
        // color and our actual output color.
        float d = min(i.dist.x, min(i.dist.y, i.dist.z)) * 1.0;
        float intensity = exp2(-2.0 * d * d);

        // width should probably be some factor of distance, but whatever.
        d = smoothstep(0.025, 0.05, d);

        // color = vec4(vec3(d), 1);
        
        if (i.color.a > 0.0001) {
            // // decode segment line from color, worldpos is actually screen pos
            d = distanceToSegment(i.worldPosition.xy, i.dist.xy, i.dist.zw);

            // d  = 1 - smoothstep(0.01, 0.5 * 0.5, d);
            d = 1 - step(u_CreaseScale * 0.5, d);

            // if (d > 0.05) {
            //     discard;
            // }

            if (d < 0.9) {
                discard;
            }

            // // smooth it
            // // d = 1.0 - d; // smoothstep(0.1, 0.2, d);
            // color = vec4(vec3(0), 1);

            color = vec4(d) * i.color;
            // color = vec4(0.1);
        } else {
            // discard;
            // draw the main color, but fade vertex edges on top of it
            color = lerp(i.color, d * i.color, 0.1);
        }
        
        // color = lerp(vec4(0.5, 0.5, 0, 1), vec4(0, 0, 0, 1), d);
    }
}

technique Main
<
    string Transparency = "Opa3que";
    // string Transparency = "Transparent";
    string index_buffer_type = "GLSL_TRIADJ";
>
{
	pass p0
	{
		VertexShader (in appdata, out vs_to_gs o) = VS;
		GeometryShader (in vs_to_gs input, out gs_to_ps o) = GS_Wireframe;
		PixelShader (in gs_to_ps i, out ps_out) = PS;
	}
}
